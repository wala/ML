<?xml version="1.0" ?>
<!DOCTYPE summary-spec>
<!-- TensorFlow model -->
<summary-spec>
  <classloader name="PythonLoader">
    <class name="tensorflow" allocatable="true">
      <method name="import" static="true" descriptor="()Ltensorflow;">
        <new def="x" class="Ltensorflow" />
        <new def="train" class="Lobject" />
        <putfield class="LRoot" field="train" fieldType="LRoot" ref="x" value="train" />
        <new def="function" class="Ltensorflow/class/function" />
        <putfield class="LRoot" field="function" fieldType="LRoot" ref="x" value="function" />
        <new def="AdamOptimizer" class="Ltensorflow/functions/AdamOptimizer" />
        <putfield class="LRoot" field="AdamOptimizer" fieldType="LRoot" ref="train" value="AdamOptimizer" />
        <new def="shuffle_batch" class="Ltensorflow/functions/shuffle_batch" />
        <putfield class="LRoot" field="shuffle_batch" fieldType="LRoot" ref="train" value="shuffle_batch" />
        <new def="InteractiveSession" class="Ltensorflow/functions/InteractiveSession" />
        <putfield class="LRoot" field="InteractiveSession" fieldType="LRoot" ref="x" value="InteractiveSession" />
        <putfield class="LRoot" field="Session" fieldType="LRoot" ref="x" value="InteractiveSession" />
        <new def="parse_single_example" class="Ltensorflow/functions/parse_single_example" />
        <putfield class="LRoot" field="parse_single_example" fieldType="LRoot" ref="x" value="parse_single_example" />
        <new def="FixedLenFeature" class="Ltensorflow/functions/FixedLenFeature" />
        <putfield class="LRoot" field="FixedLenFeature" fieldType="LRoot" ref="x" value="FixedLenFeature" />
        <new def="pass_through" class="Ltensorflow/functions/pass_through" />
        <putfield class="LRoot" field="cast" fieldType="LRoot" ref="x" value="pass_through" />
        <putfield class="LRoot" field="decode_raw" fieldType="LRoot" ref="x" value="pass_through" />
        <new def="estimator" class="Lobject" />
        <putfield class="LRoot" field="estimator" fieldType="LRoot" ref="x" value="estimator" />
        <new def="data" class="Lobject" />
        <putfield class="LRoot" field="data" fieldType="LRoot" ref="x" value="data" />
        <new def="distribute" class="Lobject" />
        <putfield class="LRoot" field="distribute" fieldType="LRoot" ref="x" value="distribute" />
        <new def="nn" class="Lobject" />
        <putfield class="LRoot" field="nn" fieldType="LRoot" ref="x" value="nn" />
        <new def="math" class="Lobject" />
        <putfield class="LRoot" field="math" fieldType="LRoot" ref="x" value="math" />
        <new def="random" class="Lobject" />
        <putfield class="LRoot" field="random" fieldType="LRoot" ref="x" value="random" />
        <new def="sparse" class="Lobject" />
        <putfield class="LRoot" field="sparse" fieldType="LRoot" ref="x" value="sparse" />
        <new def="linalg" class="Lobject" />
        <putfield class="LRoot" field="linalg" fieldType="LRoot" ref="x" value="linalg" />
        <new def="keras" class="Lobject" />
        <putfield class="LRoot" field="keras" fieldType="LRoot" ref="x" value="keras" />
        <new def="layers" class="Lobject" />
        <putfield class="LRoot" field="layers" fieldType="LRoot" ref="x" value="layers" />
        <putfield class="LRoot" field="layers" fieldType="LRoot" ref="keras" value="layers" />
        <new def="models" class="Lobject" />
        <putfield class="LRoot" field="models" fieldType="LRoot" ref="keras" value="models" />
        <new def="preprocessing" class="Lobject" />
        <putfield class="LRoot" field="preprocessing" fieldType="LRoot" ref="keras" value="preprocessing" />
        <new def="image" class="Lobject" />
        <putfield class="LRoot" field="image" fieldType="LRoot" ref="preprocessing" value="image" />
        <new def="app" class="Lobject" />
        <putfield class="LRoot" field="app" fieldType="LRoot" ref="x" value="app" />
        <new def="run" class="Ltensorflow/app/run" />
        <putfield class="LRoot" field="run" fieldType="LRoot" ref="app" value="run" />
        <new def="Estimator" class="Ltensorflow/estimator/Estimator" />
        <putfield class="LRoot" field="Estimator" fieldType="LRoot" ref="estimator" value="Estimator" />
        <new def="GradientTape" class="Ltensorflow/GradientTape" />
        <putfield class="LRoot" field="GradientTape" fieldType="LRoot" ref="x" value="GradientTape" />
        <new def="Dataset" class="Ltensorflow/data/Dataset" />
        <putfield class="LRoot" field="Dataset" fieldType="LRoot" ref="data" value="Dataset" />
        <new def="MirroredStrategy" class="Ltensorflow/distribute/MirroredStrategy" />
        <putfield class="LRoot" field="MirroredStrategy" fieldType="LRoot" ref="distribute" value="MirroredStrategy" />
        <new def="inputs" class="Lobject" />
        <putfield class="LRoot" field="inputs" fieldType="LRoot" ref="estimator" value="inputs" />
        <new def="numpy_input_fn" class="Ltensorflow/estimator/numpy_input_fn" />
        <putfield class="LRoot" field="numpy_input_fn" fieldType="LRoot" ref="inputs" value="numpy_input_fn" />
        <new def="from_tensor_slices" class="Ltensorflow/data/Dataset/from_tensor_slices" />
        <putfield class="LRoot" field="from_tensor_slices" fieldType="LRoot" ref="Dataset" value="from_tensor_slices" />
        <new def="from_generator" class="Ltensorflow/data/Dataset/from_generator" />
        <putfield class="LRoot" field="from_generator" fieldType="LRoot" ref="Dataset" value="from_generator" />
        <new def="reshape" class="Ltensorflow/functions/reshape" />
        <putfield class="LRoot" field="reshape" fieldType="LRoot" ref="x" value="reshape" />
        <new def="conv2d" class="Ltensorflow/functions/conv2d" />
        <putfield class="LRoot" field="conv2d" fieldType="LRoot" ref="x" value="conv2d" />
        <putfield class="LRoot" field="conv2d" fieldType="LRoot" ref="nn" value="conv2d" />
        <putfield class="LRoot" field="conv2d" fieldType="LRoot" ref="layers" value="conv2d" />
        <new def="conv3d" class="Ltensorflow/functions/conv3d" />
        <putfield class="LRoot" field="conv3d" fieldType="LRoot" ref="nn" value="conv3d" />
        <new def="softmax" class="Ltensorflow/functions/softmax" />
        <putfield class="LRoot" field="softmax" fieldType="LRoot" ref="nn" value="softmax" />
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/nn/relu -->
        <putfield class="LRoot" field="relu" fieldType="LRoot" ref="nn" value="pass_through" />
        <new def="sparse_softmax_cross_entropy_with_logits" class="Ltensorflow/functions/sparse_softmax_cross_entropy_with_logits" />
        <putfield class="LRoot" field="sparse_softmax_cross_entropy_with_logits" fieldType="LRoot" ref="nn" value="sparse_softmax_cross_entropy_with_logits" />
        <new def="sigmoid" class="Ltensorflow/math/sigmoid" />
        <putfield class="LRoot" field="sigmoid" fieldType="LRoot" ref="nn" value="sigmoid" />
        <putfield class="LRoot" field="sigmoid" fieldType="LRoot" ref="math" value="sigmoid" />
        <new def="add" class="Ltensorflow/math/add" />
        <putfield class="LRoot" field="add" fieldType="LRoot" ref="x" value="add" />
        <putfield class="LRoot" field="add" fieldType="LRoot" ref="math" value="add" />
        <new def="multiply" class="Ltensorflow/math/multiply" />
        <putfield class="LRoot" field="multiply" fieldType="LRoot" ref="x" value="multiply" />
        <putfield class="LRoot" field="multiply" fieldType="LRoot" ref="math" value="multiply" />
        <new def="reduce_mean" class="Ltensorflow/math/reduce_mean" />
        <putfield class="LRoot" field="reduce_mean" fieldType="LRoot" ref="x" value="reduce_mean" />
        <putfield class="LRoot" field="reduce_mean" fieldType="LRoot" ref="math" value="reduce_mean" />
        <new def="placeholder" class="Ltensorflow/functions/placeholder" />
        <putfield class="LRoot" field="placeholder" fieldType="LRoot" ref="x" value="placeholder" />
        <new def="examples" class="Lobject" />
        <putfield class="LRoot" field="examples" fieldType="LRoot" ref="x" value="examples" />
        <new def="tutorials" class="Lobject" />
        <putfield class="LRoot" field="tutorials" fieldType="LRoot" ref="examples" value="tutorials" />
        <new def="mnist" class="Lobject" />
        <putfield class="LRoot" field="mnist" fieldType="LRoot" ref="tutorials" value="mnist" />
        <new def="id" class="Ltensorflow/examples/tutorials/mnist/input_data" />
        <putfield class="LRoot" field="input_data" fieldType="LRoot" ref="mnist" value="id" />
        <new def="rds" class="Ltensorflow/examples/tutorials/mnist/read_data_sets" />
        <putfield class="LRoot" field="read_data_sets" fieldType="LRoot" ref="id" value="rds" />
        <new def="python" class="Lobject" />
        <putfield class="LRoot" field="python" fieldType="LRoot" ref="x" value="python" />
        <new def="framework" class="Lobject" />
        <putfield class="LRoot" field="framework" fieldType="LRoot" ref="python" value="framework" />
        <new def="ops" class="Lobject" />
        <putfield class="LRoot" field="ops" fieldType="LRoot" ref="python" value="ops" />
        <putfield class="LRoot" field="ops" fieldType="LRoot" ref="framework" value="ops" />
        <new def="ragged" class="Lobject" />
        <putfield class="LRoot" field="ragged" fieldType="LRoot" ref="x" value="ragged" />
        <putfield class="LRoot" field="ragged" fieldType="LRoot" ref="ops" value="ragged" />
        <new def="experimental" class="Lobject" />
        <putfield class="LRoot" field="experimental" fieldType="LRoot" ref="x" value="experimental" />
        <new def="numpy" class="Lobject" />
        <putfield class="LRoot" field="numpy" fieldType="LRoot" ref="experimental" value="numpy" />
        <new def="array_ops" class="Lobject" />
        <putfield class="LRoot" field="array_ops" fieldType="LRoot" ref="ops" value="array_ops" />
        <new def="random_ops" class="Lobject" />
        <putfield class="LRoot" field="random_ops" fieldType="LRoot" ref="ops" value="random_ops" />
        <new def="math_ops" class="Lobject" />
        <putfield class="LRoot" field="math_ops" fieldType="LRoot" ref="ops" value="math_ops" />
        <new def="linalg_ops" class="Lobject" />
        <putfield class="LRoot" field="linalg_ops" fieldType="LRoot" ref="ops" value="linalg_ops" />
        <new def="sparse_ops" class="Lobject" />
        <putfield class="LRoot" field="sparse_ops" fieldType="LRoot" ref="ops" value="sparse_ops" />
        <new def="variables" class="Lobject" />
        <putfield class="LRoot" field="variables" fieldType="LRoot" ref="ops" value="variables" />
        <new def="sparse_tensor" class="Lobject" />
        <putfield class="LRoot" field="sparse_tensor" fieldType="LRoot" ref="framework" value="sparse_tensor" />
        <new def="constant_op" class="Lobject" />
        <putfield class="LRoot" field="constant_op" fieldType="LRoot" ref="framework" value="constant_op" />
        <new def="ragged_factory_ops" class="Lobject" />
        <putfield class="LRoot" field="ragged_factory_ops" fieldType="LRoot" ref="ragged" value="ragged_factory_ops" />
        <new def="ragged_math_ops" class="Lobject" />
        <putfield class="LRoot" field="ragged_math_ops" fieldType="LRoot" ref="ragged" value="ragged_math_ops" />
        <new def="ragged_tensor" class="Lobject" />
        <putfield class="LRoot" field="ragged_tensor" fieldType="LRoot" ref="ragged" value="ragged_tensor" />
        <new def="ndarray" class="Ltensorflow/functions/ndarray" />
        <putfield class="LRoot" field="ndarray" fieldType="LRoot" ref="numpy" value="ndarray" />
        <new def="Input" class="Ltensorflow/functions/Input" />
        <putfield class="LRoot" field="Input" fieldType="LRoot" ref="keras" value="Input" />
        <putfield class="LRoot" field="Input" fieldType="LRoot" ref="layers" value="Input" />
        <new def="Dense" class="Ltensorflow/keras/layers/Dense" />
        <putfield class="LRoot" field="Dense" fieldType="LRoot" ref="layers" value="Dense" />
        <new def="Model" class="Ltensorflow/keras/models/Model" />
        <putfield class="LRoot" field="Model" fieldType="LRoot" ref="keras" value="Model" />
        <putfield class="LRoot" field="Model" fieldType="LRoot" ref="models" value="Model" />
        <new def="ImageDataGenerator" class="Ltensorflow/keras/preprocessing/image/ImageDataGenerator" />
        <putfield class="LRoot" field="ImageDataGenerator" fieldType="LRoot" ref="image" value="ImageDataGenerator" />
        <new def="Variable" class="Ltensorflow/functions/Variable" />
        <putfield class="LRoot" field="Variable" fieldType="LRoot" ref="x" value="Variable" />
        <putfield class="LRoot" field="Variable" fieldType="LRoot" ref="variables" value="Variable" />
        <new def="ones" class="Ltensorflow/functions/ones" />
        <putfield class="LRoot" field="ones" fieldType="LRoot" ref="x" value="ones" />
        <putfield class="LRoot" field="ones" fieldType="LRoot" ref="array_ops" value="ones" />
        <new def="zeros" class="Ltensorflow/functions/zeros" />
        <putfield class="LRoot" field="zeros" fieldType="LRoot" ref="x" value="zeros" />
        <putfield class="LRoot" field="zeros" fieldType="LRoot" ref="array_ops" value="zeros" />
        <new def="fill" class="Ltensorflow/functions/fill" />
        <putfield class="LRoot" field="fill" fieldType="LRoot" ref="x" value="fill" />
        <putfield class="LRoot" field="fill" fieldType="LRoot" ref="array_ops" value="fill" />
        <new def="zeros_like" class="Ltensorflow/functions/zeros_like" />
        <putfield class="LRoot" field="zeros_like" fieldType="LRoot" ref="x" value="zeros_like" />
        <putfield class="LRoot" field="zeros_like" fieldType="LRoot" ref="array_ops" value="zeros_like" />
        <new def="one_hot" class="Ltensorflow/functions/one_hot" />
        <putfield class="LRoot" field="one_hot" fieldType="LRoot" ref="x" value="one_hot" />
        <putfield class="LRoot" field="one_hot" fieldType="LRoot" ref="array_ops" value="one_hot" />
        <new def="uniform" class="Ltensorflow/functions/uniform" />
        <putfield class="LRoot" field="uniform" fieldType="LRoot" ref="random" value="uniform" />
        <putfield class="LRoot" field="random_uniform" fieldType="LRoot" ref="random_ops" value="uniform" />
        <new def="gamma" class="Ltensorflow/functions/gamma" />
        <putfield class="LRoot" field="gamma" fieldType="LRoot" ref="random" value="gamma" />
        <putfield class="LRoot" field="random_gamma" fieldType="LRoot" ref="random_ops" value="gamma" />
        <new def="normal" class="Ltensorflow/functions/normal" />
        <putfield class="LRoot" field="normal" fieldType="LRoot" ref="random" value="normal" />
        <putfield class="LRoot" field="random_normal" fieldType="LRoot" ref="random_ops" value="normal" />
        <new def="poisson" class="Ltensorflow/functions/poisson" />
        <putfield class="LRoot" field="poisson" fieldType="LRoot" ref="random" value="poisson" />
        <putfield class="LRoot" field="random_poisson_v2" fieldType="LRoot" ref="random_ops" value="poisson" />
        <new def="truncated_normal" class="Ltensorflow/functions/truncated_normal" />
        <putfield class="LRoot" field="truncated_normal" fieldType="LRoot" ref="random" value="truncated_normal" />
        <putfield class="LRoot" field="truncated_normal" fieldType="LRoot" ref="random_ops" value="truncated_normal" />
        <new def="range" class="Ltensorflow/functions/range" />
        <putfield class="LRoot" field="range" fieldType="LRoot" ref="x" value="range" />
        <putfield class="LRoot" field="range" fieldType="LRoot" ref="math_ops" value="range" />
        <new def="ragged_range" class="Ltensorflow/functions/ragged_range" />
        <putfield class="LRoot" field="range" fieldType="LRoot" ref="ragged" value="ragged_range" />
        <putfield class="LRoot" field="range" fieldType="LRoot" ref="ragged_math_ops" value="ragged_range" />
        <new def="eye" class="Ltensorflow/functions/eye" />
        <putfield class="LRoot" field="eye" fieldType="LRoot" ref="x" value="eye" />
        <putfield class="LRoot" field="eye" fieldType="LRoot" ref="linalg" value="eye" />
        <putfield class="LRoot" field="eye" fieldType="LRoot" ref="linalg_ops" value="eye" />
        <new def="constant" class="Ltensorflow/functions/constant" />
        <putfield class="LRoot" field="constant" fieldType="LRoot" ref="x" value="constant" />
        <putfield class="LRoot" field="constant" fieldType="LRoot" ref="constant_op" value="constant" />
        <new def="ragged_constant" class="Ltensorflow/functions/ragged_constant" />
        <putfield class="LRoot" field="constant" fieldType="LRoot" ref="ragged" value="ragged_constant" />
        <putfield class="LRoot" field="constant" fieldType="LRoot" ref="ragged_factory_ops" value="ragged_constant" />
        <new def="SparseTensor" class="Ltensorflow/functions/SparseTensor" />
        <putfield class="LRoot" field="SparseTensor" fieldType="LRoot" ref="x" value="SparseTensor" />
        <putfield class="LRoot" field="SparseTensor" fieldType="LRoot" ref="sparse" value="SparseTensor" />
        <putfield class="LRoot" field="SparseTensor" fieldType="LRoot" ref="sparse_tensor" value="SparseTensor" />
        <new def="sparse_eye" class="Ltensorflow/functions/sparse_eye" />
        <putfield class="LRoot" field="eye" fieldType="LRoot" ref="sparse" value="sparse_eye" />
        <putfield class="LRoot" field="sparse_eye" fieldType="LRoot" ref="sparse_ops" value="sparse_eye" />
        <new def="convert_to_tensor" class="Ltensorflow/functions/convert_to_tensor" />
        <putfield class="LRoot" field="convert_to_tensor" fieldType="LRoot" ref="x" value="convert_to_tensor" />
        <putfield class="LRoot" field="convert_to_tensor" fieldType="LRoot" ref="ops" value="convert_to_tensor" />
        <new def="Tensor" class="Ltensorflow/functions/Tensor" />
        <putfield class="LRoot" field="Tensor" fieldType="LRoot" ref="x" value="Tensor" />
        <putfield class="LRoot" field="Tensor" fieldType="LRoot" ref="ops" value="Tensor" />
        <new def="RaggedTensor" class="Lobject" />
        <putfield class="LRoot" field="RaggedTensor" fieldType="LRoot" ref="x" value="RaggedTensor" />
        <putfield class="LRoot" field="RaggedTensor" fieldType="LRoot" ref="ragged_tensor" value="RaggedTensor" />
        <new def="from_nested_row_lengths" class="Ltensorflow/functions/from_nested_row_lengths" />
        <putfield class="LRoot" field="from_nested_row_lengths" fieldType="LRoot" ref="RaggedTensor" value="from_nested_row_lengths" />
        <new def="from_nested_row_splits" class="Ltensorflow/functions/from_nested_row_splits" />
        <putfield class="LRoot" field="from_nested_row_splits" fieldType="LRoot" ref="RaggedTensor" value="from_nested_row_splits" />
        <new def="from_nested_value_rowids" class="Ltensorflow/functions/from_nested_value_rowids" />
        <putfield class="LRoot" field="from_nested_value_rowids" fieldType="LRoot" ref="RaggedTensor" value="from_nested_value_rowids" />
        <new def="from_row_lengths" class="Ltensorflow/functions/from_row_lengths" />
        <putfield class="LRoot" field="from_row_lengths" fieldType="LRoot" ref="RaggedTensor" value="from_row_lengths" />
        <new def="from_row_limits" class="Ltensorflow/functions/from_row_limits" />
        <putfield class="LRoot" field="from_row_limits" fieldType="LRoot" ref="RaggedTensor" value="from_row_limits" />
        <new def="from_row_splits" class="Ltensorflow/functions/from_row_splits" />
        <putfield class="LRoot" field="from_row_splits" fieldType="LRoot" ref="RaggedTensor" value="from_row_splits" />
        <new def="from_row_starts" class="Ltensorflow/functions/from_row_starts" />
        <putfield class="LRoot" field="from_row_starts" fieldType="LRoot" ref="RaggedTensor" value="from_row_starts" />
        <new def="from_value_rowids" class="Ltensorflow/functions/from_value_rowids" />
        <putfield class="LRoot" field="from_value_rowids" fieldType="LRoot" ref="RaggedTensor" value="from_value_rowids" />
        <return value="x" />
      </method>
    </class>
    <class name="keras" allocatable="true">
      <method name="import" static="true" descriptor="()Lkeras;">
        <new def="x" class="Lkeras" />
        <new def="engine" class="Lobject" />
        <putfield class="LRoot" field="engine" fieldType="LRoot" ref="x" value="engine" />
        <new def="input_layer" class="Lobject" />
        <putfield class="LRoot" field="input_layer" fieldType="LRoot" ref="engine" value="input_layer" />
        <new def="Input" class="Lkeras/engine/input_layer/Input" />
        <putfield class="LRoot" field="Input" fieldType="LRoot" ref="input_layer" value="Input" />
        <return value="x" />
      </method>
    </class>
    <package name="tensorflow/class">
      <class name="Function" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="self test">
          <putfield class="LRoot" field="params" fieldType="LRoot" ref="test" value="self" />
          <return value="test" />
        </method>
      </class>
      <class name="function" allocatable="true">
        <!-- These parameters are from TensorFlow v.2.9 https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/function -->
        <method name="do" descriptor="()LRoot;" numArgs="10" paramNames="func input_signature autograph jit_compile reduce_retracing experimental_implements experimental_autograph_options experimental_relax_shapes experimental_compile experimental_follow_type_hints">
          <new def="params" class="Ltensorflow/class/Function" />
          <putfield class="LRoot" field="func" fieldType="LRoot" ref="params" value="func" />
          <putfield class="LRoot" field="input_signature" fieldType="LRoot" ref="params" value="input_signature" />
          <putfield class="LRoot" field="autograph" fieldType="LRoot" ref="params" value="autograph" />
          <putfield class="LRoot" field="jit_compile" fieldType="LRoot" ref="params" value="jit_compile" />
          <putfield class="LRoot" field="reduce_retracing" fieldType="LRoot" ref="params" value="reduce_retracing" />
          <putfield class="LRoot" field="experimental_implements" fieldType="LRoot" ref="params" value="experimental_implements" />
          <putfield class="LRoot" field="experimental_autograph_options" fieldType="LRoot" ref="params" value="experimental_autograph_options" />
          <putfield class="LRoot" field="experimental_relax_shapes" fieldType="LRoot" ref="params" value="experimental_relax_shapes" />
          <putfield class="LRoot" field="experimental_compile" fieldType="LRoot" ref="params" value="experimental_compile" />
          <putfield class="LRoot" field="experimental_follow_type_hints" fieldType="LRoot" ref="params" value="experimental_follow_type_hints" />
          <return value="params" />
        </method>
      </class>
    </package>
    <package name="tensorflow/objects">
      <class name="feature" allocatable="true" />
    </package>
    <package name="keras/objects">
      <class name="feature" allocatable="true" />
    </package>
    <package name="tensorflow/math">
      <class name="sigmoid" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/nn/sigmoid -->
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self x name">
          <return value="x" />
        </method>
      </class>
      <class name="add" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/add -->
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/math/add" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self x y name">
          <!-- Even though tf.add() isn't a tensor "generator," it can convert its non-tensor arguments to tensors. -->
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="multiply" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/multiply -->
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/math/multiply" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self x y name">
          <!-- Even though tf.multiply() isn't a tensor "generator," it can convert its non-tensor arguments to tensors. -->
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="reduce_mean" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/reduce_mean -->
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="self input_tensor axis keepdims name">
          <return value="input_tensor" />
        </method>
      </class>
    </package>
    <package name="tensorflow/functions">
      <class name="AdamOptimizer" allocatable="true">
        <method name="do" descriptor="()LRoot;">
          <new def="opt" class="Lobject" />
          <new def="minimize" class="Ltensorflow/functions/minimize" />
          <putfield class="LRoot" field="minimize" fieldType="LRoot" ref="opt" value="minimize" />
          <return value="opt" />
        </method>
      </class>
      <class name="minimize" allocatable="true">
        <method name="do" descriptor="()LRoot;">
          <new def="v" class="Lobject" />
          <new def="f" class="Ltensorflow/functions/Runner" />
          <putfield class="LRoot" field="run" fieldType="LRoot" ref="v" value="f" />
          <return value="v" />
        </method>
      </class>
      <class name="shuffle_batch" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self data">
          <return value="data" />
        </method>
      </class>
      <class name="InteractiveSession" allocatable="true">
        <method name="do" descriptor="()LRoot;">
          <new def="v" class="Lobject" />
          <new def="f" class="Ltensorflow/functions/Runner" />
          <putfield class="LRoot" field="run" fieldType="LRoot" ref="v" value="f" />
          <return value="v" />
        </method>
      </class>
      <class name="Runner" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self graph feed_dict">
          <return value="self" />
        </method>
      </class>
      <class name="set_shape" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="self shape">
          <return value="self" />
        </method>
      </class>
      <class name="reshape" allocatable="true">
        <method name="copy_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/examples/tutorials/mnist/dataset" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="3">
          <call class="LRoot" name="copy_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="ones" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/array_ops/ones" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="shape dtype name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="Variable" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/variables/Variable" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="12" paramNames="initial_value trainable validate_shape caching_device name variable_def dtype import_scope constraint synchronization aggregation shape">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="constant" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/framework/constant_op/constant" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="value dtype shape name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="zeros" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/array_ops/zeros" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="shape dtype name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="SparseTensor" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/framework/sparse_tensor/SparseTensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="indices values dense_shape">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="sparse_eye" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/framework/sparse_tensor/sparse_eye" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="num_rows num_columns dtype name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="fill" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/array_ops/fill" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="dims value name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="zeros_like" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/array_ops/zeros_like" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="input dtype name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="one_hot" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/array_ops/one_hot" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="7" paramNames="indices depth on_value off_value axis dtype name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="convert_to_tensor" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/framework/ops/convert_to_tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="value dtype dtype_hint name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="range" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Llist" />
          <new def="z" class="Ltensorflow/functions/constant" />
          <call class="Ltensorflow/functions/constant" name="do" descriptor="()LRoot;" type="virtual" arg0="z" arg1="1" def="y" />
          <putfield class="LRoot" field="0" fieldType="LRoot" ref="x" value="y" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="limit delta dtype name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="Tensor" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/framework/ops/Tensor" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="op value_index dtype">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="ndarray" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/framework/ops/ndarray" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="op value_index dtype">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="ragged_range" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_math_ops/range" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="6" paramNames="starts limits deltas dtype name row_splits_dtype">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="ragged_constant" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_factory_ops/constant" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="6" paramNames="pylist dtype ragged_rank inner_shape name row_splits_dtype">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="eye" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/linalg_ops/eye" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="num_rows num_columns batch_shape dtype name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="uniform" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/random_ops/uniform" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="6" paramNames="shape minval maxval dtype seed name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="gamma" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/random_ops/gamma" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="6" paramNames="shape alpha beta dtype seed name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="normal" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/random_ops/normal" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="6" paramNames="shape mean stddev dtype seed name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="poisson" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/random_ops/poisson" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="shape lam dtype seed name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="truncated_normal" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/random_ops/truncated_normal" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="6" paramNames="shape mean stddev dtype seed name">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="Input" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/functions/Input" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="8" paramNames="shape batch_size name dtype sparse tensor ragged type_spec">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="from_nested_row_lengths" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_tensor/from_nested_row_lengths" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="flat_values nested_row_lengths name validate">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="from_nested_row_splits" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_tensor/from_nested_row_splits" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="flat_values nested_row_splits name validate">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="from_nested_value_rowids" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_tensor/from_nested_value_rowids" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="flat_values nested_value_rowids nested_nrows name validate">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="from_row_lengths" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_tensor/from_row_lengths" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="values row_lengths name validate">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="from_row_limits" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_tensor/from_row_limits" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="values row_limits name validate">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="from_row_splits" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_tensor/from_row_splits" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="values row_splits name validate">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="from_row_starts" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_tensor/from_row_starts" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="values row_starts name validate">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="from_value_rowids" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/python/ops/ragged/ragged_tensor/from_value_rowids" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="values value_rowids nrows name validate">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="placeholder" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="dtype shape name">
          <new def="x" class="Lobject" />
          <return value="x" />
        </method>
      </class>
      <class name="pass_through" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self data features">
          <return value="data" />
        </method>
      </class>
      <class name="parse_single_example" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self data features">
          <return value="features" />
        </method>
      </class>
      <class name="FixedLenFeature" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self dims type">
          <new def="x" class="Ltensorflow/objects/feature" />
          <new def="y" class="Ltensorflow/functions/set_shape" />
          <putfield class="LRoot" field="set_shape" fieldType="LRoot" ref="x" value="y" />
          <return value="x" />
        </method>
      </class>
      <class name="conv2d" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self x y">
          <return value="x" />
        </method>
      </class>
      <class name="conv3d" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self x y">
          <return value="x" />
        </method>
      </class>
      <class name="softmax" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/nn/softmax -->
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self logits axis name">
          <return value="logits" />
        </method>
      </class>
      <class name="sparse_softmax_cross_entropy_with_logits" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/nn/sparse_softmax_cross_entropy_with_logits -->
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self labels logits name">
          <return value="labels" />
        </method>
      </class>
    </package>
    <package name="tensorflow/estimator">
      <class name="Estimator" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="self model">
          <new def="x" class="Ltensorflow/estimator/train/train" />
          <putfield class="LRoot" field="train" fieldType="LRoot" ref="self" value="x" />
          <putfield class="LRoot" field="$callback" fieldType="LRoot" ref="x" value="model" />
          <return value="arg0" />
        </method>
      </class>
      <class name="numpy_input_fn" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="self x y batch_size shuffle">
          <new def="xx" class="Lobject" />
          <putfield class="LRoot" field="data" fieldType="LRoot" ref="xx" value="2" />
          <putfield class="LRoot" field="labels" fieldType="LRoot" ref="xx" value="3" />
          <return value="xx" />
        </method>
      </class>
    </package>
    <package name="tensorflow/keras/preprocessing/image">
      <class name="ImageDataGenerator" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/preprocessing/image/ImageDataGenerator -->
        <method name="read_dataset" descriptor="()LRoot;">
          <new def="flow_from_directory" class="Ltensorflow/keras/preprocessing/image/flow_from_directory" />
          <putfield class="LRoot" field="flow_from_directory" fieldType="LRoot" ref="arg0" value="flow_from_directory" />
          <return value="arg0" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="24"
          paramNames="self featurewise_center samplewise_center featurewise_std_normalization samplewise_std_normalization zca_whitening zca_epsilon rotation_range width_shift_range height_shift_range brightness_range shear_range zoom_range channel_shift_range fill_mode cval horizontal_flip vertical_flip rescale preprocessing_function data_format validation_split interpolation_order dtype">
          <!-- NOTE: Workaround for https://github.com/wala/ML/issues/127. This ctor doesn't really return a dataset but rather the instance methods do. It shouldn't be a problem since you can't iterate over an `ImageDataGenerator`. -->
          <call class="LRoot" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="flow_from_directory" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/preprocessing/image/ImageDataGenerator#flow_from_directory -->
        <method name="do" descriptor="()LRoot;" numArgs="16" paramNames="self directory target_size color_mode classes class_mode batch_size shuffle seed save_to_dir save_prefix save_format follow_links subset interpolation keep_aspect_ratio">
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" def="xx" />
          <return value="xx" />
        </method>
      </class>
    </package>
    <package name="tensorflow/keras/models">
      <class name="Model" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/keras/Model/attribute" />
          <return value="x" />
        </method>
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/models/Model -->
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self inputs outputs name">
          <new def="__call__" class="Ltensorflow/keras/models/__call__" />
          <putfield class="LRoot" field="__call__" fieldType="LRoot" ref="arg0" value="__call__" />
          <new def="call" class="Ltensorflow/keras/models/call" />
          <putfield class="LRoot" field="call" fieldType="LRoot" ref="arg0" value="call" />
          <new def="x" class="Llist" />
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="xx" />
          <putfield class="LRoot" field="0" fieldType="LRoot" ref="x" value="xx" />
          <!-- https://www.tensorflow.org/guide/keras/transfer_learning#freezing_layers_understanding_the_trainable_attribute -->
          <putfield class="LRoot" field="trainable_weights" fieldType="LRoot" ref="arg0" value="x" />
          <putfield class="LRoot" field="weights" fieldType="LRoot" ref="arg0" value="x" />
          <putfield class="LRoot" field="non_trainable_weights" fieldType="LRoot" ref="arg0" value="x" />
          <return value="arg0" />
        </method>
      </class>
      <class name="__call__" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/Model#call -->
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self inputs training mask">
          <return value="inputs" />
        </method>
      </class>
      <!-- FIXME: Workaround for https://github.com/wala/ML/issues/106. -->
      <class name="call" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/Model#call -->
        <method name="do" descriptor="()LRoot;" numArgs="4" paramNames="self inputs training mask">
          <return value="inputs" />
        </method>
      </class>
    </package>
    <package name="tensorflow/keras/layers">
      <class name="Dense" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/keras/layers/Dense -->
        <method name="do" descriptor="()LRoot;" numArgs="11" paramNames="self units activation use_bias kernel_initializer bias_initializer kernel_regularizer bias_regularizer activity_regularizer kernel_constraint bias_constraint">
          <new def="__call__" class="Ltensorflow/keras/layers/__call__" />
          <putfield class="LRoot" field="__call__" fieldType="LRoot" ref="arg0" value="__call__" />
          <new def="call" class="Ltensorflow/keras/layers/call" />
          <putfield class="LRoot" field="call" fieldType="LRoot" ref="arg0" value="call" />
          <return value="arg0" />
        </method>
      </class>
      <!-- FIXME: These methods must be called explicitly. The implicit cases blocked on https://github.com/wala/ML/issues/127. -->
      <class name="__call__" allocatable="true">
        <!-- https://github.com/keras-team/keras/blob/07e13740fd181fc3ddec7d9a594d8a08666645f6/keras/layers/core/dense.py#L166-L240 -->
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="self inputs">
          <return value="inputs" />
        </method>
      </class>
      <!-- FIXME: Workaround for https://github.com/wala/ML/issues/106. -->
      <class name="call" allocatable="true">
        <!-- https://github.com/keras-team/keras/blob/07e13740fd181fc3ddec7d9a594d8a08666645f6/keras/layers/core/dense.py#L166-L240 -->
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="self inputs">
          <return value="inputs" />
        </method>
      </class>
    </package>
    <package name="tensorflow">
      <class name="GradientTape" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/GradientTape -->
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self persistent watch_accessed_variables">
          <new def="gradient" class="Ltensorflow/gradient" />
          <putfield class="LRoot" field="gradient" fieldType="LRoot" ref="arg0" value="gradient" />
          <return value="arg0" />
        </method>
      </class>
      <class name="gradient" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/GradientTape#gradient -->
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="self target sources output_gradients unconnected_gradients">
          <return value="sources" />
        </method>
      </class>
    </package>
    <package name="tensorflow/data">
      <class name="Dataset" allocatable="true">
        <!-- "read_dataset" means that this function reads a tensor iterable. -->
        <method name="read_dataset" descriptor="()LRoot;">
          <new def="shuffle" class="Ltensorflow/data/shuffle" />
          <putfield class="LRoot" field="shuffle" fieldType="LRoot" ref="arg0" value="shuffle" />
          <new def="batch" class="Ltensorflow/data/batch" />
          <putfield class="LRoot" field="batch" fieldType="LRoot" ref="arg0" value="batch" />
          <new def="repeat" class="Ltensorflow/data/repeat" />
          <putfield class="LRoot" field="repeat" fieldType="LRoot" ref="arg0" value="repeat" />
          <new def="prefetch" class="Ltensorflow/data/prefetch" />
          <putfield class="LRoot" field="prefetch" fieldType="LRoot" ref="arg0" value="prefetch" />
          <new def="take" class="Ltensorflow/data/take" />
          <putfield class="LRoot" field="take" fieldType="LRoot" ref="arg0" value="take" />
          <return value="arg0" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="self variant_tensor">
          <call class="LRoot" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
      <class name="shuffle" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#shuffle -->
        <method name="do" descriptor="()LRoot;" numArgs="5" paramNames="self buffer_size seed reshuffle_each_iteration name">
          <!-- FIXME: Workaround for https://github.com/wala/ML/issues/127. This method (shuffle) doesn't really return a "new" dataset but rather a modified version of the receiver. But, the receiver isn't available without a trampoline AFAIK. -->
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="batch" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#batch -->
        <method name="do" descriptor="()LRoot;" numArgs="6" paramNames="self batch_size drop_remainder num_parallel_calls deterministic name">
          <!-- FIXME: Workaround for https://github.com/wala/ML/issues/127. -->
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="repeat" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#repeat -->
        <method name="do" descriptor="()LRoot;" numArgs="6" paramNames="self count name">
          <!-- FIXME: Workaround for https://github.com/wala/ML/issues/127. -->
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="prefetch" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#prefetch -->
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self buffer_size name">
          <!-- FIXME: Workaround for https://github.com/wala/ML/issues/127. -->
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="take" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#take -->
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self count name">
          <!-- FIXME: Workaround for https://github.com/wala/ML/issues/127. -->
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" def="xx" />
          <return value="xx" />
        </method>
      </class>
    </package>
    <package name="tensorflow/data/Dataset">
      <class name="from_tensor_slices" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#from_tensor_slices -->
        <method name="do" descriptor="()LRoot;" numArgs="2" paramNames="tensors name">
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" def="xx" />
          <return value="xx" />
        </method>
      </class>
      <class name="from_generator" allocatable="true">
        <!-- https://www.tensorflow.org/versions/r2.9/api_docs/python/tf/data/Dataset#from_generator -->
        <method name="do" descriptor="()LRoot;" numArgs="6" paramNames="generator output_types output_shapes args output_signature name">
          <new def="x" class="Ltensorflow/data/Dataset" />
          <call class="Ltensorflow/data/Dataset" name="read_dataset" descriptor="()LRoot;" type="virtual" arg0="x" def="xx" />
          <return value="xx" />
        </method>
      </class>
    </package>
    <package name="tensorflow/estimator/train">
      <class name="train" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3">
          <getfield class="LRoot" field="$callback" fieldType="LRoot" ref="arg0" def="xx" />
          <getfield class="LRoot" field="data" fieldType="LRoot" ref="arg1" def="data" />
          <call class="LRoot" name="do" descriptor="()LRoot;" type="virtual" arg0="xx" arg1="data" arg2="3" numArgs="3" def="v" />
          <return value="v" />
        </method>
      </class>
    </package>
    <package name="tensorflow/distribute">
      <class name="MirroredStrategy" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self devices cross_device_ops">
          <new def="x" class="Ltensorflow/distribute/run/run" />
          <putfield class="LRoot" field="run" fieldType="LRoot" ref="self" value="x" />
          <return value="arg0" />
        </method>
      </class>
    </package>
    <package name="tensorflow/distribute/run">
      <class name="run" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3">
          <getfield class="LRoot" field="0" fieldType="LRoot" ref="arg2" def="x" />
          <call class="LRoot" name="do" descriptor="()LRoot;" type="virtual" arg0="arg1" arg1="x" numArgs="2" def="v" />
          <return value="v" />
        </method>
      </class>
    </package>
    <package name="tensorflow/app">
      <class name="run" allocatable="true">
        <method name="do" descriptor="()LRoot;" numArgs="3" paramNames="self main argv">
          <call class="LRoot" name="do" descriptor="()LRoot;" type="virtual" arg0="arg1" arg1="" def="v" />
          <return value="v" />
        </method>
      </class>
    </package>
    <package name="tensorflow/examples/tutorials/mnist">
      <class name="read_data_sets" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Ltensorflow/examples/tutorials/mnist/dataset" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;">
          <new def="test" class="Lobject" />
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <putfield class="LRoot" field="images" fieldType="LRoot" ref="test" value="x" />
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="y" />
          <new def="training" class="Lobject" />
          <putfield class="LRoot" field="images" fieldType="LRoot" ref="training" value="y" />
          <new def="data" class="Lobject" />
          <putfield class="LRoot" field="test" fieldType="LRoot" ref="data" value="test" />
          <putfield class="LRoot" field="train" fieldType="LRoot" ref="data" value="training" />
          <return value="data" />
        </method>
      </class>
      <class name="input_data" allocatable="true">
      </class>
      <class name="dataset" allocatable="true">
      </class>
    </package>
    <package name="tensorflow/examples/tutorials">
      <class name="mnist" allocatable="true">
        <method name="import" static="true" descriptor="()Ltensorflow/examples/tutorials/mnist;">
          <new def="x" class="Ltensorflow/examples/tutorials/mnist" />
          <call name="__init__" class="Ltensorflow/examples/tutorials/mnist" descriptor="()V" type="virtual" arg0="x" />
          <return value="x" />
        </method>
        <method name="__init__" descriptor="()V">
          <new def="x" class="Ltensorflow/examples/tutorials/mnist/input_data" />
          <new def="y" class="Ltensorflow/examples/tutorials/mnist/read_data_sets" />
          <putfield class="Ltensorflow/examples/tutorials/mnist" field="input_data" fieldType="LRoot" ref="arg0" value="x" />
          <putfield class="Ltensorflow/examples/tutorials/mnist/input_data" field="read_data_sets" fieldType="LRoot" ref="x" value="y" />
        </method>
      </class>
    </package>
    <package name="keras/engine/input_layer">
      <class name="Input" allocatable="true">
        <method name="read_data" descriptor="()LRoot;">
          <new def="x" class="Lkeras/engine/input_layer/Input" />
          <return value="x" />
        </method>
        <method name="do" descriptor="()LRoot;" numArgs="8" paramNames="shape batch_size name dtype sparse tensor ragged type_spec">
          <call class="LRoot" name="read_data" descriptor="()LRoot;" type="virtual" arg0="arg0" def="x" />
          <return value="x" />
        </method>
      </class>
    </package>
  </classloader>
</summary-spec>
